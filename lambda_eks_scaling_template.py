#!/usr/bin/env python3
"""
EKS Cluster NodeGroup Scaling Lambda Function
Handles scheduled scaling of EKS nodegroups based on EventBridge events
Supports both single and multiple nodegroup scaling operations
Template version with injectable parameters
Generated on: {{CURRENT_DATETIME}}
Created by: {{CURRENT_USER}}
"""

import boto3
import json
import logging
import os
import time
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Any, Optional
from botocore.exceptions import ClientError

# Configure enhanced logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)


# Create custom formatter for better log structure
class CustomFormatter(logging.Formatter):
    def format(self, record):
        timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
        level = record.levelname
        message = record.getMessage()
        return f"[{timestamp}] [{level}] {message}"


# Apply custom formatter to existing handlers
for handler in logger.handlers:
    handler.setFormatter(CustomFormatter())


class EKSNodeGroupScaler:
    def __init__(self):
        self.logger = logger
        self.start_time = None
        self.execution_stats = {
            'nodegroups_processed': 0,
            'successful_operations': 0,
            'skipped_operations': 0,
            'failed_operations': 0,
            'warnings_issued': 0,
            'total_scaling_changes': 0
        }

    def log_execution_start(self, cluster_name, region, action, ist_time):
        """Log execution start with detailed context"""
        self.start_time = time.time()
        self.logger.info("=" * 80)
        self.logger.info("ğŸš€ EKS NODEGROUP SCALING LAMBDA - EXECUTION START")
        self.logger.info("=" * 80)
        self.logger.info(f"ğŸ“… Execution Time: {datetime.utcnow().isoformat()}Z")
        self.logger.info(f"ğŸ¯ Target Cluster: {cluster_name}")
        self.logger.info(f"ğŸŒ Target Region: {region}")
        self.logger.info(f"âš¡ Scaling Action: {action.upper()}")
        self.logger.info(f"ğŸ• IST Time: {ist_time}")
        self.logger.info(f"ğŸ‘¤ Generated By: {{CURRENT_USER}}")
        self.logger.info(f"ğŸ“ Template Generated: {{CURRENT_DATETIME}}")
        self.logger.info("=" * 80)

    def log_execution_end(self, success=True):
        """Log execution end with summary statistics"""
        execution_time = time.time() - self.start_time if self.start_time else 0
        self.logger.info("=" * 80)
        self.logger.info("ğŸ EKS NODEGROUP SCALING LAMBDA - EXECUTION END")
        self.logger.info("=" * 80)
        self.logger.info(f"â±ï¸  Total Execution Time: {execution_time:.2f} seconds")
        self.logger.info(f"ğŸ“Š Nodegroups Processed: {self.execution_stats['nodegroups_processed']}")
        self.logger.info(f"âœ… Successful Operations: {self.execution_stats['successful_operations']}")
        self.logger.info(f"â­ï¸  Skipped Operations: {self.execution_stats['skipped_operations']}")
        self.logger.info(f"âŒ Failed Operations: {self.execution_stats['failed_operations']}")
        self.logger.info(f"ğŸ“ˆ Total Scaling Changes: {self.execution_stats['total_scaling_changes']}")
        self.logger.info(f"âš ï¸  Warnings Issued: {self.execution_stats['warnings_issued']}")
        self.logger.info(
            f"ğŸ¯ Success Rate: {(self.execution_stats['successful_operations'] + self.execution_stats['skipped_operations']) / max(1, self.execution_stats['nodegroups_processed']) * 100:.1f}%")
        self.logger.info(f"âœ… Execution Status: {'SUCCESS' if success else 'FAILED'}")
        self.logger.info("=" * 80)

    def calculate_ist_time(self):
        """Calculate current IST time with logging"""
        self.logger.info("ğŸ• IST time not provided in event, calculating current IST time...")

        try:
            # Calculate current IST time (UTC + 5:30)
            ist_timezone = timezone(timedelta(hours=5, minutes=30))
            current_ist = datetime.now(ist_timezone)
            ist_time = current_ist.strftime('%I:%M %p IST')

            self.logger.info(f"âœ… Current IST time calculated: {ist_time}")
            return ist_time

        except Exception as e:
            self.logger.warning(f"âš ï¸  Error calculating IST time: {str(e)} - using UTC time")
            self.execution_stats['warnings_issued'] += 1
            utc_time = datetime.utcnow().strftime('%I:%M %p UTC')
            return utc_time

    def validate_nodegroup_config(self, ng_config, index):
        """Validate nodegroup configuration with detailed logging"""
        nodegroup_name = ng_config.get('name')

        if not nodegroup_name:
            self.logger.warning(f"âš ï¸  [{index}] Skipping nodegroup with missing name: {ng_config}")
            self.execution_stats['warnings_issued'] += 1
            return None

        # Get scaling parameters with defaults
        desired_size = ng_config.get('desired_size', 1)
        min_size = ng_config.get('min_size', 0)
        max_size = ng_config.get('max_size', 3)

        # Validate scaling configuration logic
        if min_size > max_size:
            self.logger.warning(
                f"âš ï¸  [{index}] Invalid config for {nodegroup_name}: min_size ({min_size}) > max_size ({max_size})")
            self.execution_stats['warnings_issued'] += 1

        if desired_size < min_size or desired_size > max_size:
            self.logger.warning(
                f"âš ï¸  [{index}] Invalid config for {nodegroup_name}: desired_size ({desired_size}) not between min_size ({min_size}) and max_size ({max_size})")
            self.execution_stats['warnings_issued'] += 1

        self.logger.info(
            f"âœ… [{index}] Validated config for {nodegroup_name}: min={min_size}, desired={desired_size}, max={max_size}")

        return {
            'name': nodegroup_name,
            'desired_size': desired_size,
            'min_size': min_size,
            'max_size': max_size
        }

    def get_current_nodegroup_config(self, eks_client, cluster_name, nodegroup_name):
        """Get current nodegroup configuration with enhanced logging"""
        self.logger.info(f"   â”œâ”€â”€ ğŸ“‹ Retrieving current configuration...")

        try:
            current_ng = eks_client.describe_nodegroup(
                clusterName=cluster_name,
                nodegroupName=nodegroup_name
            )

            nodegroup_info = current_ng['nodegroup']
            current_scaling = nodegroup_info.get('scalingConfig', {})

            current_config = {
                'desired': current_scaling.get('desiredSize', 0),
                'min': current_scaling.get('minSize', 0),
                'max': current_scaling.get('maxSize', 0)
            }

            # Log additional nodegroup details
            status = nodegroup_info.get('status', 'unknown')
            capacity_type = nodegroup_info.get('capacityType', 'unknown')
            instance_types = nodegroup_info.get('instanceTypes', ['unknown'])

            self.logger.info(
                f"   â”œâ”€â”€ ğŸ“Š Current scaling: min={current_config['min']}, desired={current_config['desired']}, max={current_config['max']}")
            self.logger.info(f"   â”œâ”€â”€ ğŸ“ˆ Status: {status}")
            self.logger.info(f"   â”œâ”€â”€ ğŸ’¾ Capacity Type: {capacity_type}")
            self.logger.info(f"   â”œâ”€â”€ ğŸ–¥ï¸  Instance Types: {instance_types}")

            if status != 'ACTIVE':
                self.logger.warning(f"   âš ï¸  Nodegroup status is {status}, not ACTIVE")
                self.execution_stats['warnings_issued'] += 1

            return current_config

        except ClientError as e:
            error_code = e.response['Error']['Code']
            if error_code == 'ResourceNotFoundException':
                self.logger.error(f"   âŒ Nodegroup {nodegroup_name} not found in cluster {cluster_name}")
            elif error_code == 'AccessDeniedException':
                self.logger.error(f"   âŒ Access denied to nodegroup {nodegroup_name} - check IAM permissions")
            else:
                self.logger.error(f"   âŒ AWS API error: {error_code} - {e.response['Error']['Message']}")
            raise
        except Exception as e:
            self.logger.error(f"   âŒ Unexpected error retrieving nodegroup config: {str(e)}")
            raise

    def update_nodegroup_scaling(self, eks_client, cluster_name, nodegroup_name, target_config):
        """Update nodegroup scaling configuration with detailed logging"""
        self.logger.info(f"   â”œâ”€â”€ ğŸ”„ Initiating scaling configuration update...")

        try:
            response = eks_client.update_nodegroup_config(
                clusterName=cluster_name,
                nodegroupName=nodegroup_name,
                scalingConfig={
                    'minSize': target_config['min_size'],
                    'maxSize': target_config['max_size'],
                    'desiredSize': target_config['desired_size']
                }
            )

            update_id = response['update']['id']
            update_status = response['update']['status']

            self.logger.info(f"   â”œâ”€â”€ âœ… Scaling update initiated successfully")
            self.logger.info(f"   â”œâ”€â”€ ğŸ†” Update ID: {update_id}")
            self.logger.info(f"   â”œâ”€â”€ ğŸ“Š Update Status: {update_status}")
            self.logger.info(
                f"   â””â”€â”€ ğŸ¯ New configuration will be: min={target_config['min_size']}, desired={target_config['desired_size']}, max={target_config['max_size']}")

            self.execution_stats['total_scaling_changes'] += 1

            return {
                'update_id': update_id,
                'status': update_status
            }

        except ClientError as e:
            error_code = e.response['Error']['Code']
            error_message = e.response['Error']['Message']

            if error_code == 'InvalidParameterException':
                self.logger.error(f"   âŒ Invalid scaling parameters: {error_message}")
            elif error_code == 'ResourceInUseException':
                self.logger.error(f"   âŒ Nodegroup is currently being updated: {error_message}")
            elif error_code == 'InvalidRequestException':
                self.logger.error(f"   âŒ Invalid request: {error_message}")
            else:
                self.logger.error(f"   âŒ AWS API error: {error_code} - {error_message}")
            raise
        except Exception as e:
            self.logger.error(f"   âŒ Unexpected error updating nodegroup: {str(e)}")
            raise

    def process_nodegroup(self, eks_client, cluster_name, ng_config, index, total):
        """Process individual nodegroup scaling with comprehensive logging"""
        nodegroup_name = ng_config['name']
        target_config = {
            'desired_size': ng_config['desired_size'],
            'min_size': ng_config['min_size'],
            'max_size': ng_config['max_size']
        }

        self.logger.info(f"ğŸ“¦ [{index}/{total}] Processing nodegroup: {nodegroup_name}")
        self.logger.info(
            f"   â”œâ”€â”€ ğŸ¯ Target: min={target_config['min_size']}, desired={target_config['desired_size']}, max={target_config['max_size']}")

        try:
            # Get current configuration
            current_config = self.get_current_nodegroup_config(eks_client, cluster_name, nodegroup_name)

            # Check if update is needed
            if (current_config['min'] == target_config['min_size'] and
                    current_config['desired'] == target_config['desired_size'] and
                    current_config['max'] == target_config['max_size']):
                self.logger.info(f"   â”œâ”€â”€ â­ï¸  No changes needed - scaling configuration already matches target")
                self.logger.info(f"   â””â”€â”€ âœ… Skipping update for {nodegroup_name}")

                self.execution_stats['skipped_operations'] += 1
                return {
                    'nodegroup': nodegroup_name,
                    'status': 'skipped',
                    'message': 'Configuration unchanged',
                    'current': {
                        'min': current_config['min'],
                        'desired': current_config['desired'],
                        'max': current_config['max']
                    }
                }

            # Perform the update
            update_result = self.update_nodegroup_scaling(eks_client, cluster_name, nodegroup_name, target_config)

            self.execution_stats['successful_operations'] += 1
            self.execution_stats['nodegroups_processed'] += 1

            return {
                'nodegroup': nodegroup_name,
                'status': 'success',
                'update_id': update_result['update_id'],
                'update_status': update_result['status'],
                'previous': {
                    'min': current_config['min'],
                    'desired': current_config['desired'],
                    'max': current_config['max']
                },
                'new': {
                    'min': target_config['min_size'],
                    'desired': target_config['desired_size'],
                    'max': target_config['max_size']
                }
            }

        except Exception as e:
            error_msg = str(e)
            self.logger.error(f"   âŒ Failed to process nodegroup {nodegroup_name}: {error_msg}")

            self.execution_stats['failed_operations'] += 1
            self.execution_stats['nodegroups_processed'] += 1

            return {
                'nodegroup': nodegroup_name,
                'status': 'error',
                'error': error_msg,
                'target': {
                    'min': target_config['min_size'],
                    'desired': target_config['desired_size'],
                    'max': target_config['max_size']
                }
            }

    def scale_nodegroups(self, cluster_name, region, action, ist_time, nodegroups_config):
        """Main scaling logic with enhanced logging and error handling"""
        self.log_execution_start(cluster_name, region, action, ist_time)

        try:
            # Create EKS client with connection testing
            self.logger.info("ğŸ”§ Initializing AWS EKS client...")
            eks_client = boto3.client('eks', region_name=region)

            # Test connectivity
            try:
                sts_client = boto3.client('sts', region_name=region)
                identity = sts_client.get_caller_identity()
                self.logger.info(f"âœ… AWS connectivity verified - Account: {identity.get('Account')}")
                self.logger.info(f"   User/Role ARN: {identity.get('Arn')}")
            except Exception as e:
                self.logger.warning(f"âš ï¸  Could not verify AWS identity: {str(e)}")
                self.execution_stats['warnings_issued'] += 1

            # Validate input
            if not nodegroups_config:
                error_msg = "No nodegroups specified in the event"
                self.logger.error(f"âŒ Validation failed: {error_msg}")
                return {
                    'statusCode': 400,
                    'body': json.dumps({
                        'success': False,
                        'error': error_msg,
                        'cluster': cluster_name,
                        'region': region,
                        'timestamp': datetime.utcnow().isoformat() + 'Z'
                    })
                }

            self.logger.info(f"ğŸ“‹ PHASE 1: VALIDATING {len(nodegroups_config)} NODEGROUP CONFIGURATIONS")
            self.logger.info("â”€" * 60)

            # Validate all nodegroup configurations
            valid_configs = []
            for i, ng_config in enumerate(nodegroups_config, 1):
                validated_config = self.validate_nodegroup_config(ng_config, i)
                if validated_config:
                    valid_configs.append(validated_config)

            if not valid_configs:
                error_msg = "No valid nodegroup configurations found"
                self.logger.error(f"âŒ {error_msg}")
                self.log_execution_end(success=False)
                return {
                    'statusCode': 400,
                    'body': json.dumps({
                        'success': False,
                        'error': error_msg,
                        'cluster': cluster_name,
                        'region': region,
                        'timestamp': datetime.utcnow().isoformat() + 'Z'
                    })
                }

            self.logger.info(
                f"âœ… Validation complete: {len(valid_configs)}/{len(nodegroups_config)} configurations valid")

            # Process scaling operations
            self.logger.info(f"ğŸš€ PHASE 2: EXECUTING SCALING OPERATIONS")
            self.logger.info("â”€" * 60)

            results = []
            for i, ng_config in enumerate(valid_configs, 1):
                result = self.process_nodegroup(eks_client, cluster_name, ng_config, i, len(valid_configs))
                results.append(result)

            # Calculate final statistics
            total_processed = len(valid_configs)
            success_rate = ((self.execution_stats['successful_operations'] + self.execution_stats[
                'skipped_operations']) / max(1, total_processed)) * 100

            self.logger.info("ğŸ“Š SCALING OPERATION SUMMARY:")
            self.logger.info(f"   â”œâ”€â”€ Total nodegroups: {total_processed}")
            self.logger.info(f"   â”œâ”€â”€ Successful operations: {self.execution_stats['successful_operations']}")
            self.logger.info(f"   â”œâ”€â”€ Skipped operations: {self.execution_stats['skipped_operations']}")
            self.logger.info(f"   â”œâ”€â”€ Failed operations: {self.execution_stats['failed_operations']}")
            self.logger.info(f"   â”œâ”€â”€ Success rate: {success_rate:.1f}%")
            self.logger.info(f"   â””â”€â”€ Total scaling changes: {self.execution_stats['total_scaling_changes']}")

            self.log_execution_end(success=True)

            # Prepare response
            summary = {
                'success': True,
                'timestamp': datetime.utcnow().isoformat() + 'Z',
                'cluster': cluster_name,
                'region': region,
                'action': action,
                'ist_time': ist_time,
                'total_nodegroups': total_processed,
                'successful_operations': self.execution_stats['successful_operations'],
                'skipped_operations': self.execution_stats['skipped_operations'],
                'failed_operations': self.execution_stats['failed_operations'],
                'success_rate_percent': round(success_rate, 1),
                'total_scaling_changes': self.execution_stats['total_scaling_changes'],
                'execution_stats': self.execution_stats,
                'results': results,
                'processed_by': 'eks-nodegroup-scaling-lambda',
                'processed_by_user': '{{CURRENT_USER}}',
                'generated_on': '{{CURRENT_DATETIME}}'
            }

            return {
                'statusCode': 200 if self.execution_stats['failed_operations'] == 0 else 207,  # 207 = Multi-Status
                'body': json.dumps(summary, default=str)
            }

        except Exception as e:
            error_msg = str(e)
            self.logger.error(f"ğŸ’¥ Scaling operation failed with unexpected error: {error_msg}")
            self.log_execution_end(success=False)

            return {
                'statusCode': 500,
                'body': json.dumps({
                    'success': False,
                    'error': error_msg,
                    'cluster': cluster_name,
                    'region': region,
                    'execution_stats': self.execution_stats,
                    'timestamp': datetime.utcnow().isoformat() + 'Z'
                })
            }


# Create global instance
scaler = EKSNodeGroupScaler()


def lambda_handler(event, context):
    """
    AWS Lambda entry point for EKS nodegroup scaling

    Template variables that will be injected:
    - {{cluster_name}}: EKS cluster name
    - {{region}}: AWS region
    - {{CURRENT_USER}}: User who generated this function
    - {{CURRENT_DATETIME}}: Date Time when function was generated
    """
    try:
        logger.info(f"ğŸš€ EKS Scaling Lambda function invoked")
        logger.info(f"ğŸ“ Function ARN: {context.invoked_function_arn}")
        logger.info(f"ğŸ“… Template generated: {{CURRENT_DATETIME}}")
        logger.info(f"ğŸ‘¤ Generated by user: {{CURRENT_USER}}")
        logger.info(f"â±ï¸  Remaining execution time: {context.get_remaining_time_in_millis()}ms")
        logger.info(f"ğŸ’¾ Memory limit: {context.memory_limit_in_mb}MB")

        # Log event (safely)
        logger.info(f"ğŸ“¥ Event received: {json.dumps(event, indent=2)}")

        # Get configuration from template injection or event
        cluster_name = cluster_name = "{{ cluster_name }}" if "{{ cluster_name }}" != "" else event.get("cluster_name") or os.environ.get("CLUSTER_NAME")
        region = '{{region}}' if '{{region}}' != "" else event.get('region') or os.environ.get('REGION')

        # Validate required parameters
        if not cluster_name:
            error_msg = 'cluster_name is required in template injection, event payload, or CLUSTER_NAME environment variable'
            logger.error(f"âŒ Validation failed: {error_msg}")
            return {
                'statusCode': 400,
                'body': json.dumps({
                    'success': False,
                    'error': error_msg,
                    'timestamp': datetime.utcnow().isoformat() + 'Z'
                })
            }

        if not region:
            error_msg = 'region is required in template injection, event, or AWS_REGION environment variable'
            logger.error(f"âŒ Validation failed: {error_msg}")
            return {
                'statusCode': 400,
                'body': json.dumps({
                    'success': False,
                    'error': error_msg,
                    'cluster_name': cluster_name,
                    'timestamp': datetime.utcnow().isoformat() + 'Z'
                })
            }

        # Process the event
        action = event.get('action', 'unknown')

        # Get IST time - if not provided, calculate current IST time
        ist_time = event.get('ist_time')
        if not ist_time or ist_time == 'unknown time':
            ist_time = scaler.calculate_ist_time()

        nodegroups_config = event.get('nodegroups', [])

        logger.info(f"ğŸ”§ Configuration resolved:")
        logger.info(f"   â”œâ”€â”€ Cluster: {cluster_name}")
        logger.info(f"   â”œâ”€â”€ Region: {region}")
        logger.info(f"   â”œâ”€â”€ Action: {action}")
        logger.info(f"   â”œâ”€â”€ IST Time: {ist_time}")
        logger.info(f"   â””â”€â”€ Nodegroups: {len(nodegroups_config)} configured")

        # Run the scaling logic
        result = scaler.scale_nodegroups(cluster_name, region, action, ist_time, nodegroups_config)

        logger.info(f"ğŸ‰ Lambda execution completed with status: {result['statusCode']}")
        return result

    except Exception as e:
        logger.error(f"ğŸ’¥ Lambda handler failed with unexpected error: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'success': False,
                'error': f'Lambda execution failed: {str(e)}',
                'timestamp': datetime.utcnow().isoformat() + 'Z'
            })
        }


"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“‹ SAMPLE EVENT STRUCTURES FOR TESTING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ğŸŒ… MORNING SCALE-UP EVENT (Basic):
{
    "action": "scale_up",
    "ist_time": "8:30 AM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-general",
            "desired_size": 2,
            "min_size": 1,
            "max_size": 5
        }
    ]
}

2. ğŸŒ™ EVENING SCALE-DOWN EVENT (Basic):
{
    "action": "scale_down",
    "ist_time": "6:30 PM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-general",
            "desired_size": 0,
            "min_size": 0,
            "max_size": 5
        }
    ]
}

3. ğŸš€ MULTI-NODEGROUP SCALE-UP EVENT (Production):
{
    "action": "scale_up",
    "ist_time": "8:00 AM IST",
    "cluster_name": "eks-cluster-prod-us-east-1-main",
    "region": "us-east-1",
    "nodegroups": [
        {
            "name": "eks-nodegroup-web-servers",
            "desired_size": 3,
            "min_size": 2,
            "max_size": 8
        },
        {
            "name": "eks-nodegroup-api-servers",
            "desired_size": 2,
            "min_size": 1,
            "max_size": 6
        },
        {
            "name": "eks-nodegroup-background-workers",
            "desired_size": 1,
            "min_size": 0,
            "max_size": 4
        }
    ]
}

4. ğŸ“‰ MULTI-NODEGROUP SCALE-DOWN EVENT (Production):
{
    "action": "scale_down",
    "ist_time": "7:00 PM IST",
    "cluster_name": "eks-cluster-prod-us-east-1-main",
    "region": "us-east-1",
    "nodegroups": [
        {
            "name": "eks-nodegroup-web-servers",
            "desired_size": 1,
            "min_size": 1,
            "max_size": 8
        },
        {
            "name": "eks-nodegroup-api-servers",
            "desired_size": 1,
            "min_size": 1,
            "max_size": 6
        },
        {
            "name": "eks-nodegroup-background-workers",
            "desired_size": 0,
            "min_size": 0,
            "max_size": 4
        }
    ]
}

5. ğŸ§ª TESTING EVENT (Development Environment):
{
    "action": "scale_up",
    "ist_time": "10:00 AM IST",
    "cluster_name": "eks-cluster-dev-us-west-2-test",
    "region": "us-west-2",
    "nodegroups": [
        {
            "name": "eks-nodegroup-dev-1",
            "desired_size": 1,
            "min_size": 0,
            "max_size": 3
        },
        {
            "name": "eks-nodegroup-dev-2",
            "desired_size": 1,
            "min_size": 0,
            "max_size": 3
        }
    ]
}

6. ğŸ”§ MAINTENANCE MODE EVENT (Scale to Minimum):
{
    "action": "maintenance_mode",
    "ist_time": "2:00 AM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-general",
            "desired_size": 1,
            "min_size": 1,
            "max_size": 10
        },
        {
            "name": "eks-nodegroup-spot",
            "desired_size": 0,
            "min_size": 0,
            "max_size": 5
        }
    ]
}

7. âš¡ BURST SCALING EVENT (High Traffic):
{
    "action": "burst_scale",
    "ist_time": "11:00 AM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-web-tier",
            "desired_size": 10,
            "min_size": 5,
            "max_size": 15
        },
        {
            "name": "eks-nodegroup-app-tier",
            "desired_size": 6,
            "min_size": 3,
            "max_size": 12
        }
    ]
}

8. ğŸŒ CROSS-REGION EVENT (EU West):
{
    "action": "scale_up",
    "ist_time": "2:30 PM IST",
    "cluster_name": "eks-cluster-prod-eu-west-1-main", 
    "region": "eu-west-1",
    "nodegroups": [
        {
            "name": "eks-nodegroup-eu-web",
            "desired_size": 2,
            "min_size": 1,
            "max_size": 6
        }
    ]
}

9. âŒ ERROR TEST EVENT (Invalid Configuration):
{
    "action": "scale_up",
    "ist_time": "9:00 AM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-invalid",
            "desired_size": 5,
            "min_size": 8,
            "max_size": 3
        }
    ]
}

10. ğŸ“­ EMPTY EVENT (Tests Environment Variables):
{
    "action": "test_connection"
}

11. ğŸ”„ SPOT INSTANCE SCALING EVENT:
{
    "action": "scale_spot_instances",
    "ist_time": "9:30 AM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-spot-workers",
            "desired_size": 5,
            "min_size": 2,
            "max_size": 10
        },
        {
            "name": "eks-nodegroup-spot-batch",
            "desired_size": 3,
            "min_size": 0,
            "max_size": 8
        }
    ]
}

12. ğŸš¨ EMERGENCY SCALE DOWN EVENT:
{
    "action": "emergency_scale_down",
    "ist_time": "11:45 PM IST",
    "nodegroups": [
        {
            "name": "eks-nodegroup-web-servers",
            "desired_size": 1,
            "min_size": 1,
            "max_size": 10
        },
        {
            "name": "eks-nodegroup-api-servers",
            "desired_size": 1,
            "min_size": 1,
            "max_size": 8
        },
        {
            "name": "eks-nodegroup-workers",
            "desired_size": 0,
            "min_size": 0,
            "max_size": 5
        }
    ]
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ EVENTBRIDGE SCHEDULED EVENT EXAMPLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EventBridge Rule Pattern for Morning Scale-Up (8:30 AM IST = 3:00 AM UTC):
{
    "Rules": [
        {
            "Name": "eks-morning-scale-up",
            "ScheduleExpression": "cron(0 3 * * ? *)",
            "Targets": [
                {
                    "Id": "1",
                    "Arn": "arn:aws:lambda:us-east-1:123456789012:function:eks-scaling-function",
                    "Input": "{\"action\": \"scale_up\", \"ist_time\": \"8:30 AM IST\", \"nodegroups\": [{\"name\": \"eks-nodegroup-general\", \"desired_size\": 2, \"min_size\": 1, \"max_size\": 5}]}"
                }
            ]
        }
    ]
}

EventBridge Rule Pattern for Evening Scale-Down (6:30 PM IST = 1:00 PM UTC):
{
    "Rules": [
        {
            "Name": "eks-evening-scale-down",
            "ScheduleExpression": "cron(0 13 * * ? *)",
            "Targets": [
                {
                    "Id": "1", 
                    "Arn": "arn:aws:lambda:us-east-1:123456789012:function:eks-scaling-function",
                    "Input": "{\"action\": \"scale_down\", \"ist_time\": \"6:30 PM IST\", \"nodegroups\": [{\"name\": \"eks-nodegroup-general\", \"desired_size\": 0, \"min_size\": 0, \"max_size\": 5}]}"
                }
            ]
        }
    ]
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”§ ENVIRONMENT VARIABLES (Fallback Configuration)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CLUSTER_NAME: eks-cluster-account01_clouduser01-us-east-1-wxie
AWS_REGION: us-east-1

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š TEMPLATE INJECTION VARIABLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{{cluster_name}}: Will be replaced with actual EKS cluster name
{{region}}: Will be replaced with actual AWS region
{{CURRENT_USER}}: User who generated this function
{{CURRENT_DATETIME}}: Date time when function was generated

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""


def main():
    """
    Local testing function - simulates Lambda execution with template values
    """
    print("ğŸ§ª LOCAL TEST MODE ACTIVATED")
    print("=" * 80)
    print(f"ğŸ“… Template generated: {{CURRENT_DATETIME}}")
    print(f"ğŸ‘¤ Generated by: {{CURRENT_USER}}")
    print("=" * 80)

    # Test events
    scale_up_event = {
        "action": "scale_up",
        "ist_time": "8:30 AM IST",
        "nodegroups": [
            {
                "name": "test-nodegroup-1",
                "desired_size": 2,
                "min_size": 1,
                "max_size": 3
            },
            {
                "name": "test-nodegroup-2",
                "desired_size": 1,
                "min_size": 1,
                "max_size": 3
            }
        ]
    }

    scale_down_event = {
        "action": "scale_down",
        "ist_time": "6:30 PM IST",
        "nodegroups": [
            {
                "name": "test-nodegroup-1",
                "desired_size": 0,
                "min_size": 0,
                "max_size": 3
            },
            {
                "name": "test-nodegroup-2",
                "desired_size": 0,
                "min_size": 0,
                "max_size": 3
            }
        ]
    }

    # Mock Lambda context
    class MockContext:
        def __init__(self):
            self.function_name = 'eks-nodegroup-scaling-function'
            self.function_version = '$LATEST'
            self.invoked_function_arn = 'arn:aws:lambda:{{region}}:123456789012:function:eks-scaling-function'
            self.memory_limit_in_mb = '256'
            self.remaining_time_in_millis = 60000
            self.log_group_name = '/aws/lambda/eks-scaling-function'
            self.log_stream_name = '{{current_date}}/[$LATEST]test'

        def get_remaining_time_in_millis(self):
            return self.remaining_time_in_millis

    context = MockContext()

    try:
        print("\nğŸš€ Testing SCALE UP operation...")
        result = lambda_handler(scale_up_event, context)
        print(f"Status Code: {result['statusCode']}")
        if result.get('body'):
            body = json.loads(result['body'])
            print(json.dumps(body, indent=2))

        print("\nğŸš€ Testing SCALE DOWN operation...")
        result = lambda_handler(scale_down_event, context)
        print(f"Status Code: {result['statusCode']}")
        if result.get('body'):
            body = json.loads(result['body'])
            print(json.dumps(body, indent=2))

        print("\nâœ… Local testing completed!")

    except Exception as e:
        print(f"ğŸ’¥ Local test failed with error: {str(e)}")


if __name__ == "__main__":
    main()